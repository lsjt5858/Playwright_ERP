## **前言**

在测试工程师的工作中，需求文档（通常为 `docx` 格式）是最重要的测试资产之一。然而，需求文档往往夹杂页眉、页脚、目录、模板固有内容等无用信息，且格式复杂多样，不同项目的文档格式差异较大。这些无效内容会导致测试用例设计和需求分析的效率下降。因此，设计一个智能清理需求文档的工具，可以帮助测试工程师大幅提升工作效率。

本文将深入探讨如何对 `docx` 格式的需求文档进行智能清理，提供详细的清理步骤及验收标准，配合 **PyQt5** 图形界面实现灵活操作。我们将确保清理功能具备高扩展性，能够适配多种文档格式和用户需求。

---

## **清理需求文档的详尽步骤**

### **步骤 1：提取文档内容**

**目的**：将文档中的段落、表格、页眉、页脚等内容解析为可操作的数据结构。

#### **实现逻辑**：
- 使用 `python-docx` 库解析文档。
- 区分段落和表格内容，按顺序提取。
- 提取页眉和页脚内容，单独存储以便后续处理。

#### **验收标准**：
- 能正确提取文档的段落和表格内容。
- 页眉和页脚内容能独立存储，便于后续清理。

#### **代码实现**：
```python
from docx import Document

def extract_content(file_path):
    """
    提取需求文档内容，包括段落、表格、页眉和页脚。
    :param file_path: docx 文件路径
    :return: dict, 包括段落、表格、页眉和页脚
    """
    doc = Document(file_path)
    content = {"paragraphs": [], "tables": [], "headers": [], "footers": []}

    # 提取段落
    for paragraph in doc.paragraphs:
        if paragraph.text.strip():
            content["paragraphs"].append(paragraph.text.strip())

    # 提取表格内容
    for table in doc.tables:
        table_data = []
        for row in table.rows:
            row_data = [cell.text.strip() for cell in row.cells]
            table_data.append(row_data)
        content["tables"].append(table_data)

    # 提取页眉和页脚（如果有）
    if doc.sections:
        for section in doc.sections:
            if section.header:
                content["headers"].append(section.header.paragraphs[0].text.strip())
            if section.footer:
                content["footers"].append(section.footer.paragraphs[0].text.strip())

    return content
```

---

### **步骤 2：清理页眉、页脚和目录**

**目的**：去除文档中多余的页眉、页脚和目录等非业务内容。

#### **实现逻辑**：
1. **页眉和页脚**：检测是否包含固定模板内容（如项目名称、页码等），通过关键字匹配过滤。
2. **目录**：通过正则表达式匹配目录特征（如 "第x章"、"x.x.x" 等）并删除。

#### **验收标准**：
- 页眉和页脚内容成功移除，只保留正文有价值信息。
- 目录内容被正确识别并剔除，正文结构完整。

#### **代码实现**：
```python
import re

def clean_headers_footers(content):
    """
    清理页眉、页脚和目录内容
    :param content: 文档内容字典
    :return: 清理后的段落和表格
    """
    cleaned_content = {"paragraphs": [], "tables": content["tables"]}

    # 清理页眉和页脚中的无用内容
    headers_footers = content["headers"] + content["footers"]
    for paragraph in content["paragraphs"]:
        # 如果段落在页眉或页脚中，过滤掉
        if paragraph in headers_footers:
            continue
        # 过滤掉可能是目录的内容
        if re.match(r"^\s*(第[\d一二三四五六七八九十]+章|\d+(\.\d+)*).*$", paragraph):
            continue
        cleaned_content["paragraphs"].append(paragraph)

    return cleaned_content
```

---

### **步骤 3：剔除模板固有内容**

**目的**：删除文档中的模板注释和固有内容，如 "请填写"、"此处为模板" 等无用信息。

#### **实现逻辑**：
- 通过关键短语匹配删除模板固有内容。
- 支持用户配置更多的模板关键短语，保持扩展性。

#### **验收标准**：
- 模板注释和无用内容全部移除，正文逻辑清晰。

#### **代码实现**：
```python
template_phrases = ["请填写", "此处为模板", "示例", "模板内容", "请参考以下格式"]

def remove_template_phrases(content):
    """
    删除文档中的模板固有内容
    :param content: 文档段落列表
    :return: 清理后的段落列表
    """
    cleaned_paragraphs = []
    for paragraph in content["paragraphs"]:
        if any(phrase in paragraph for phrase in template_phrases):
            continue  # 跳过模板内容
        cleaned_paragraphs.append(paragraph)
    return {"paragraphs": cleaned_paragraphs, "tables": content["tables"]}
```

---

### **步骤 4：格式化并输出清理结果**

**目的**：将清理后的内容统一存储为 JSON 格式，以便后续的检索或进一步加工。

#### **实现逻辑**：
- 将段落和表格内容存储为键值对。
- 保证 JSON 的格式化输出，便于人工验收。

#### **验收标准**：
- 清理后的文档内容以 JSON 格式输出，结构清晰。

#### **代码实现**：
```python
import json

def save_to_json(content, output_path):
    """
    将清理后的文档内容保存为 JSON 格式
    :param content: 清理后的文档内容
    :param output_path: 输出文件路径
    """
    with open(output_path, "w", encoding="utf-8") as f:
        json.dump(content, f, ensure_ascii=False, indent=4)
```

---

### **PyQt5 GUI 界面实现**

以下是一个基于 **PyQt5** 的简单界面，支持文件选择、清理预览和保存。

#### **代码实现**：
```python
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QFileDialog, QVBoxLayout, QLabel, QTextEdit, QPushButton, QWidget
)

class DocxCleanerGUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("智能清理需求文档工具")
        self.setGeometry(200, 200, 800, 600)
        self.initUI()

    def initUI(self):
        layout = QVBoxLayout()

        # 文件选择按钮
        self.select_file_btn = QPushButton("选择需求文档")
        self.select_file_btn.clicked.connect(self.select_file)
        layout.addWidget(self.select_file_btn)

        # 文件内容预览
        self.file_content_preview = QTextEdit()
        self.file_content_preview.setReadOnly(True)
        layout.addWidget(QLabel("原始文档内容："))
        layout.addWidget(self.file_content_preview)

        # 清理后内容预览
        self.cleaned_content_preview = QTextEdit()
        self.cleaned_content_preview.setReadOnly(False)
        layout.addWidget(QLabel("清理后文档内容："))
        layout.addWidget(self.cleaned_content_preview)

        # 清理按钮
        self.clean_btn = QPushButton("清理文档")
        self.clean_btn.clicked.connect(self.clean_file)
        layout.addWidget(self.clean_btn)

        # 保存按钮
        self.save_btn = QPushButton("保存清理结果")
        self.save_btn.clicked.connect(self.save_file)
        layout.addWidget(self.save_btn)

        # 设置中心布局
        container = QWidget()
        container.setLayout(layout)
        self.setCentralWidget(container)

    def select_file(self):
        file_path, _ = QFileDialog.getOpenFileName(self, "选择DOCX文件", "", "Word文件 (*.docx)")
        if file_path:
            self.file_path = file_path
            content = extract_content(file_path)
            self.file_content_preview.setText("\n".join(content["paragraphs"]))

    def clean_file(self):
        if hasattr(self, "file_path"):
            content = extract_content(self.file_path)
            cleaned_content = clean_headers_footers(content)
            cleaned_content = remove_template_phrases(cleaned_content)
            self.cleaned_content_preview.setText("\n".join(cleaned_content["paragraphs"]))

    def save_file(self):
        if hasattr(self, "file_path"):
            output_path, _ = QFileDialog.getSaveFileName(self, "保存清理结果", "", "JSON文件 (*.json)")
            if output_path:
                content = {"paragraphs": self.cleaned_content_preview.toPlainText().split("\n")}
                save_to_json(content, output_path)

if __name__ == "__main__":
    app = QApplication([])
    window = DocxCleanerGUI()
    window.show()
    app.exec_()
```

---

## **扩展性建议**

1. **支持自定义规则**：允许用户添加或修改匹配规则（如模板短语、正则表达式），满足不同项目需求。
2. **多格式支持**：扩展支持 `xlsx`、`pdf`、`md` 等文档格式的清理。
3. **误删修复机制**：提供误删恢复功能，记录被移除内容，供用户手动恢复。
4. **批量处理**：支持批量上传和清理多个文档。

---

## **总结**

本文详细阐述了如何对 `docx` 格式的需求文档进行智能清理，包含页眉、页脚、目录、模板内容的清理逻辑，以及如何通过关键字和正则表达式准确匹配无用数据。通过 PyQt5 GUI 的实现，用户可以灵活操作和调整清理结果，确保文档清理准确可靠。扩展性设计保证工具能适配多种场景，真正实现高效可落地的需求文档处理！