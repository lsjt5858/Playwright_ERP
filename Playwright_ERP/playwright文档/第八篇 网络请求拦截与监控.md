
在自动化测试中，**网络请求拦截与监控** 是一个非常强大的工具。它不仅可以让我们监听页面发出的 HTTP 请求和响应，还能通过修改或模拟请求数据来控制页面行为，例如：
- **Mock 数据**：模拟 API 返回的数据，避免依赖后端服务。
- **性能监控**：记录请求的耗时、状态码，用于分析页面性能。
- **请求拦截**：阻止资源加载（如广告、图像），加速测试执行。

本篇文章将深入讲解 Playwright 的网络请求拦截与监控功能，通过丰富的示例代码展示其强大能力，并结合与 Selenium 的对比，帮助你在测试中更好地掌控页面网络行为。

---

## 1. Playwright 网络拦截与监控的优势

1. **内置监听机制**：通过 `on("request")` 和 `on("response")` 事件，轻松监听网络行为。
2. **Mock 数据内置支持**：直接通过 `route` 方法模拟 API 数据。
3. **灵活的请求控制**：支持修改请求头、拦截请求、禁用资源加载等。
4. **性能测试辅助**：可记录请求耗时、状态码等详细信息。

相比 Selenium，Playwright 支持原生的网络拦截与 Mock 功能，而 Selenium 需要借助第三方工具（如 `BrowserMob Proxy`），配置复杂，功能有限。

---

## 2. 监听网络请求与响应

### **2.1 监听 HTTP 请求**

通过 `page.on("request")`，可以监听页面发出的所有 HTTP 请求。

**代码示例：打印所有请求的 URL**
```python
from playwright.sync_api import sync_playwright

with sync_playwright() as p:
    browser = p.chromium.launch(headless=False)
    page = browser.new_page()

    # 监听所有请求
    def handle_request(request):
        print(f"Request URL: {request.url}")
        print(f"Method: {request.method}")
        print(f"Headers: {request.headers}")

    page.on("request", handle_request)

    # 打开页面
    page.goto("https://example.com")

    browser.close()
```

**解释**：
- `request.url` 获取请求的 URL。
- `request.method` 获取请求方法（如 `GET`、`POST`）。
- `request.headers` 获取请求头信息。

---

### **2.2 监听 HTTP 响应**

通过 `page.on("response")`，可以监听所有响应，并记录状态码和响应时间。

**代码示例：打印响应状态码**
```python
# 监听所有响应
def handle_response(response):
    print(f"Response URL: {response.url}")
    print(f"Status: {response.status}")
    print(f"Response Time: {response.timing['responseEnd']} ms")

page.on("response", handle_response)
page.goto("https://example.com")
```

**解释**：
- `response.status` 获取 HTTP 状态码（如 `200`、`404`）。
- `response.timing` 提供详细的时间信息（如响应时间）。

---

## 3. 拦截并修改请求

通过 `page.route()`，可以拦截特定的请求并修改其数据（如请求头、URL、方法等）。

### **3.1 修改请求头**

**代码示例：为所有请求添加自定义头**
```python
# 拦截并修改请求头
def handle_route(route, request):
    headers = request.headers
    headers["Authorization"] = "Bearer my_token"  # 添加自定义头
    route.continue_(headers=headers)

page.route("**/*", handle_route)
page.goto("https://example.com")
```

**解释**：
- `route.continue_()` 用于继续请求，并可以修改请求头等数据。

---

### **3.2 阻止资源加载**

可以通过拦截请求来阻止加载某些资源（如图像、广告），从而加速测试。

**代码示例：阻止加载所有图像**
```python
# 拦截并阻止图像加载
def block_images(route, request):
    if request.resource_type == "image":
        route.abort()  # 阻止请求
    else:
        route.continue_()

page.route("**/*", block_images)
page.goto("https://example.com")
```

**解释**：
- `route.abort()` 用于阻止请求。
- `request.resource_type` 判断请求的资源类型（如 `image`、`script`、`stylesheet` 等）。

---

## 4. Mock 数据

Mock 数据是测试中非常常见的需求，Playwright 提供了简单易用的 `route.fulfill()` 方法，可以拦截请求并返回自定义数据。

### **4.1 返回自定义响应**

**代码示例：Mock API 返回数据**
```python
# Mock API 数据
def mock_api(route):
    response_data = {"message": "Hello from mocked API!"}
    route.fulfill(
        status=200,
        content_type="application/json",
        body=json.dumps(response_data),  # 返回自定义的 JSON 数据
    )

page.route("https://api.example.com/data", mock_api)
page.goto("https://example.com")
```

**解释**：
- `route.fulfill()` 用于模拟响应数据。
- `status` 指定 HTTP 状态码，`body` 是返回的数据内容。

---

### **4.2 模拟延迟响应**

可以通过 `route.fulfill()` 模拟延迟响应，用于测试前端的加载状态。

**代码示例：模拟 2 秒延迟**
```python
import time

def mock_api_with_delay(route):
    time.sleep(2)  # 模拟延迟
    response_data = {"message": "Delayed response"}
    route.fulfill(
        status=200,
        content_type="application/json",
        body=json.dumps(response_data),
    )

page.route("https://api.example.com/data", mock_api_with_delay)
page.goto("https://example.com")
```

---

## 5. 实战案例：拦截与 Mock API

### **场景描述**
1. 打开电商网站首页。
2. Mock 商品列表的 API 数据，返回自定义商品。
3. 阻止加载所有广告资源，加速页面加载。
4. 打印所有 API 响应的状态码。

### **代码实现**
```python
from playwright.sync_api import sync_playwright
import json

def run(playwright):
    browser = playwright.chromium.launch(headless=False)
    page = browser.new_page()

    # Mock 商品列表 API
    def mock_products(route):
        mock_data = [
            {"id": 1, "name": "Mocked Product 1", "price": 100},
            {"id": 2, "name": "Mocked Product 2", "price": 200},
        ]
        route.fulfill(
            status=200,
            content_type="application/json",
            body=json.dumps(mock_data),
        )

    page.route("https://api.ecommerce.com/products", mock_products)

    # 阻止广告加载
    def block_ads(route, request):
        if "ads" in request.url:
            route.abort()
        else:
            route.continue_()

    page.route("**/*", block_ads)

    # 监听响应状态码
    def log_response(response):
        print(f"Response URL: {response.url}, Status: {response.status}")

    page.on("response", log_response)

    # 打开页面
    page.goto("https://ecommerce.com")

    browser.close()

with sync_playwright() as playwright:
    run(playwright)
```

---

## 6. 与 Selenium 的对比

| **功能**               | **Playwright**                                   | **Selenium**                                                                 |
|------------------------|--------------------------------------------------|------------------------------------------------------------------------------|
| 网络请求监听           | 原生支持，API 简单直接                          | 不支持，需搭配 `BrowserMob Proxy` 等工具                                    |
| 请求拦截与修改         | 支持拦截并修改请求头、URL、方法等                | 配置 Proxy 后可实现，但较复杂                                                |
| Mock 数据支持          | 内置 `route.fulfill()`，简单易用                 | 无原生支持，需搭配 Mock 服务器                                               |
| 性能监控               | 支持记录请求耗时、状态码等详细信息               | 需额外工具实现                                                               |

---

## 7. 常见问题及解决思路

### **问题 1**：拦截规则未生效
**解决方案**：确保 `page.route()` 的规则匹配正确，支持通配符（如 `**/*`）。

---

### **问题 2**：Mock 数据未覆盖所有请求
**解决方案**：使用更精确的匹配规则，或者在日志中打印未匹配的请求 URL 以便调试。例如：
```python
def debug_requests(route, request):
    print(f"Unhandled request: {request.url}")
    route.continue_()
```

---

### **问题 3**：请求拦截导致页面加载失败
**解决方案**：确保必要的资源（如脚本、样式表）未被错误拦截，可以根据资源类型设置条件。

---

## 8. 小结

本篇文章深入剖析了 Playwright 的网络请求拦截与监控功能，从监听请求与响应、拦截和修改请求到 Mock 数据返回，结合了多个实战案例，展示了 Playwright 在网络控制上的强大能力。通过对比 Selenium，可以看出 Playwright 的网络功能更加灵活和高效。

### **亮点**：
- **Mock 数据**：轻松模拟 API 响应，避免依赖后端数据。
- **请求拦截**：用于屏蔽广告或动态资源，提升测试效率。
- **性能监控**：帮助分析页面加载性能。

---

**预告**：下一篇文章将探讨 **测试中的调试技巧与最佳实践**，包括如何高效排查问题、优化测试脚本，以及与 CI/CD 集成的技巧。敬请期待！