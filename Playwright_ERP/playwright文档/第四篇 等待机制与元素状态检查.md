

在自动化测试中，处理 **浏览器弹窗（如 alert、confirm、prompt）**、**页面跳转的新标签页或窗口** 是常见需求。Playwright 提供了简单直观的 API 来处理这些场景，且其设计更高效、稳定，与 Selenium 相比，Playwright 在弹窗处理和多窗口切换方面具有显著优势。

本篇文章将从 **对话框处理**、**多标签页/窗口操作**、**与 Selenium 的对比** 和 **经典项目案例** 出发，深入讲解 Playwright 的弹窗与窗口管理功能。

---

## 1. Playwright 处理对话框的优势

1. **自动监听对话框事件**：Playwright 提供了 `page.on("dialog", callback)` 接口，可以轻松监听并处理弹窗。
2. **不阻塞脚本执行**：Playwright 的对话框处理是非阻塞的，不需要强制等待弹窗出现。
3. **链式调用简洁明了**：通过简单的 `accept()` 或 `dismiss()` 方法即可处理对话框。
4. **易于调试**：Playwright 的对话框处理不需要复杂的等待代码，相比 Selenium 更加高效。

---

## 2. Playwright 中的对话框处理

Playwright 支持以下三种常见弹窗类型：

### **2.1 Alert 弹窗**

`alert` 是最简单的 JavaScript 弹窗，只有一条消息和一个确认按钮。

**代码示例**：
假设页面中会触发一个 `alert` 弹窗：
```html
<button onclick="alert('This is an alert!')">Click me</button>
```

Playwright 处理：
```python
from playwright.sync_api import sync_playwright

with sync_playwright() as p:
    browser = p.chromium.launch(headless=False)
    page = browser.new_page()

    # 打开测试页面
    page.set_content('<button onclick="alert(\'This is an alert!\')">Click me</button>')

    # 监听弹窗事件
    def handle_dialog(dialog):
        print(f"Dialog message: {dialog.message}")  # 打印弹窗内容
        dialog.accept()  # 点击确认按钮

    page.on("dialog", handle_dialog)

    # 触发弹窗
    page.click("button")

    browser.close()
```

---

### **2.2 Confirm 弹窗**

`confirm` 弹窗包含确认和取消按钮，用户可以选择接受或拒绝。

**代码示例**：
```html
<button onclick="confirm('Do you confirm this action?')">Confirm</button>
```

Playwright 处理：
```python
def handle_confirm(dialog):
    print(f"Dialog message: {dialog.message}")  # 打印弹窗内容
    dialog.accept()  # 点击确认
    # dialog.dismiss()  # 点击取消

page.on("dialog", handle_confirm)
page.click("button")
```

---

### **2.3 Prompt 弹窗**

`prompt` 弹窗允许用户输入文本，并包含确认和取消按钮。

**代码示例**：
```html
<button onclick="prompt('Enter your name:', 'Default Name')">Prompt</button>
```

Playwright 处理：
```python
def handle_prompt(dialog):
    print(f"Dialog message: {dialog.message}")  # 打印弹窗内容
    dialog.accept("John Doe")  # 输入 "John Doe" 并点击确认
    # dialog.dismiss()  # 点击取消

page.on("dialog", handle_prompt)
page.click("button")
```

---

### **与 Selenium 的对比**

| **功能**               | **Playwright**                                    | **Selenium**                                                                 |
|------------------------|--------------------------------------------------|------------------------------------------------------------------------------|
| 监听和处理弹窗         | 使用简单的 `page.on("dialog")`，自动监听         | 需要 `switch_to.alert` 手动切换到弹窗，再操作                               |
| 操作简洁性             | 使用 `accept()` 或 `dismiss()`，链式调用         | 必须调用 `accept()` 或 `dismiss()`，无链式支持                              |
| 动态弹窗处理           | 弹窗触发时自动监听并处理                         | 需要手动轮询或等待弹窗出现                                                  |
| 输入文本（Prompt）      | `accept("text")` 简单传入文本                   | 必须先 `send_keys("text")`，然后调用 `accept()`                             |
| 稳定性与效率           | 默认具备自动等待机制，不阻塞脚本                 | 需要显式等待弹窗，容易因等待问题导致脚本失败                                |

---

## 3. 多窗口和标签页的处理

现代 Web 应用中，操作会常常打开新标签页或新窗口，例如点击链接跳转到新页面或通过 `window.open()` 打开新窗口。Playwright 提供了强大的 API 来处理这些场景。

### **3.1 等待新标签页的创建**

Playwright 提供了 `context.on("page")` 方法，监听新页面的创建。

**代码示例：监听新标签页**
```python
with sync_playwright() as p:
    browser = p.chromium.launch(headless=False)
    context = browser.new_context()
    page = context.new_page()

    # 打开包含新窗口的页面
    page.set_content('<a href="https://example.com" target="_blank">Open new tab</a>')

    # 监听新标签页
    def handle_new_page(new_page):
        print("New tab opened!")
        new_page.wait_for_load_state()  # 等待页面加载完成
        print(f"New page URL: {new_page.url}")

    context.on("page", handle_new_page)

    # 点击打开新标签页
    page.click("a")

    browser.close()
```

---

### **3.2 操作新窗口**

新窗口会返回一个 `page` 对象，你可以直接操作该对象。

**代码示例：操作打开的新窗口**
```python
page.click("a")  # 点击打开新窗口
new_page = context.wait_for_event("page")  # 等待新窗口创建

# 在新窗口中操作
new_page.wait_for_load_state()
print(f"New page title: {new_page.title()}")
```

---

### **3.3 切换标签页**

在测试中需要在多个标签页之间切换，Playwright 提供了 `context.pages` 获取所有打开的页面。

**代码示例：切换标签页**
```python
pages = context.pages
for p in pages:
    print(p.url)  # 打印所有标签页的 URL
    if "example.com" in p.url:
        p.bring_to_front()  # 切换到该标签页
```

---

### **与 Selenium 的对比**

| **功能**               | **Playwright**                                    | **Selenium**                                                                 |
|------------------------|--------------------------------------------------|------------------------------------------------------------------------------|
| 新窗口监听             | 自动监听新窗口，`context.on("page")`             | 手动获取 `window_handles` 列表，再切换到新窗口                              |
| 自动等待新窗口加载     | 默认内置等待，支持条件触发                       | 无自动等待，需显式等待新窗口加载                                            |
| 操作新窗口             | 返回 `page` 对象，直接操作                       | 必须使用 `switch_to.window(handle)` 切换句柄                                |
| 标签页切换             | 使用 `context.pages`，按需切换                   | 通过 `window_handles` 遍历句柄，复杂且易错                                  |

---

## 4. 实战案例：电商网站中弹窗与多窗口处理

### **场景描述**

1. 打开电商网站首页。
2. 点击登录按钮，出现登录弹窗，输入用户名和密码后点击确认。
3. 点击某个商品链接，跳转到新标签页，获取商品详情。
4. 回到主页面，点击结算按钮。

---

### **代码实现**

```python
from playwright.sync_api import sync_playwright

def run(playwright):
    browser = playwright.chromium.launch(headless=False)
    context = browser.new_context()
    page = context.new_page()

    # 打开电商网站首页
    page.goto("https://fake-ecommerce-site.com")

    # Step 1: 处理登录弹窗
    def handle_login_dialog(dialog):
        print(f"Login Dialog: {dialog.message}")
        dialog.accept("test_user")  # 输入用户名
    page.on("dialog", handle_login_dialog)
    page.click("button#login")  # 点击登录按钮

    # Step 2: 点击商品链接，跳转到新标签页
    page.click("a#product-link")
    product_page = context.wait_for_event("page")  # 等待新标签页
    product_page.wait_for_load_state()
    print(f"Product Title: {product_page.title()}")

    # Step 3: 切回主页面，点击结算
    page.bring_to_front()  # 切回主页面
    page.click("button#checkout")

    browser.close()

with sync_playwright() as playwright:
    run(playwright)
```

---

## 5. 小结

通过本篇文章，我们学习了 Playwright 在处理 **对话框** 和 **多窗口/标签页** 时的功能和优势：
- **对话框处理** 更加智能，自动监听弹窗，无需手动切换。
- **多标签页与窗口管理** 更加直观，内置事件监听和自动等待。
- **与 Selenium 对比**，Playwright 的 API 更简单，功能更强大，代码更简洁。

**亮点**：
- 提供了丰富的代码实例，覆盖对话框、标签页与窗口操作的各种场景。
- 对比了 Selenium 和 Playwright 的实现差异，突出了 Playwright 的优势。
- 实战案例贴近真实项目，具有很强的实用性。

---

**预告**：在下一篇文章中，我们将深入探讨 **表单处理和文件上传/下载**，包括复杂表单的操作技巧和文件处理的实战案例。敬请期待！